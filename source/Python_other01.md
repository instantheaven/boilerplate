**セル**
セルをまとめたファイルの事をノートブック(ipnbファイル)と呼ぶ

Pythonのソースファイルには「**～.py**」という名前を指定する慣習

```算術演算子の種類```

| 演算子  | 説明  | 例  | 例の表示結果  |
|---|---|---|---|
|``` +```  | 足し算(加算)  | ```print(10+10)```  | ```20```  |
| ```-```  | 引き算(減算)  | ```print(10-1)```  | ```9```  |
|  ```*``` |  掛け算(乗算)  | ```print(2*3)```  |  ```6``` |
|  ```/``` |  割り算(除算)　※結果は小数 |  ```print(7/4)``` | ```1.75```  |
|  ```//``` | 割り算の商　※結果は整数  |  ```print(7//4)``` | ```1```  |
| ```%```  | 割り算の余り  |```print(7%4)```  | ```3```  |
| ```**```  | べき乗(累乗)  |``` print(2**3)```  | ```8```  |

```文字列における算術演算子```

| 演算子  | 説明  | 例  |  例の表示結果 |
|---|---|---|---|
|  ```+``` | 文字列の連結  | ```print('1'+'1')```  |  ```11``` |
|  ```*``` | 文字列の反復(文字列```*```数値または数値```*```文字列のとき)  | ```print('オラ'```*```3)```  | ```オラオラオラ```  |
 
 
```代表的なエスケープシーケンス```

|  表記 |  意味 |
|---|---|
| ```\n```  |  改行を表す制御文字 |
| ```\\```  | ```\```(バックスラッシュ)  |
| ```\'```  | ```'```(シングルクォーテーション)  |
| ```\"```  | ```"```(ダブルクォーテーション)  |

 
```演算子の優先順位```

| 優先順位  | 演算子  |
|---|---|
| 高  |  ```**``` |
| 中  | ```*、/、%```  |
| 低  |  ```+、-``` |
 
 ---

L1.ipynb  
  
.ipynbはJupiterLab用の拡張子  
高機能  
  

```複数の単語から作る識別子の命令規則```  
```・アッパーキャメルケース :MyAge、UploadData```  
```・ロワーキャメルケース :myAge、uploadData```  
```・スネークケース :my_age、UPLOAD_DATA```  
```・チェインケース :my-age、UPLOAD-DATA```  
  
**アンパック代入**  
複数の変数をまとめて定義  
```name, age='浅木',24```  
変数と値をそれぞれ「,」(カンマ)でつなげて書きます。この代入方法のことを**アンパック代入**と呼びます  
  
インクリメント、デクリメントはない  

  
**値と変数のデータ型**  
値にはデータ型の定めがあるが、変数はデータ型を持たない  
  
```格納されている値のデータ型を調べる```  
```x=10```  
```print(type(x))```  
```実行結果```  
```<class 'int'>```  
  
Javaは何でも文字列連結できるけど  
Pythonは型変換しないと連結できない  
文字列連結する場合は文字列に変換してから  
  
```print('お支払いは',payment,'円です',sep='')```  
引数で渡すのは便利  
sepはどういう風に文字列連結するかの指定  
  

**Pythonの場合、演算は、文字列同士か数値同士でしか出来ない**  
  
**format関数**  
JavaのString.formatみたいな  
printfみたいな  
｛｝はプレースホルダー  
  
```print('私の名前は{}で、年齢は{}歳で、身長は{}c,です'.format(name,age,height))```  
```print(f'私の名前は{name}で年齢は{age}歳で、身長は{height}です')```  
  
# コレクション

``` リストの定義
変数={要素1,要素2,要素3,…}
※要素には、数値や文字列などを指定できる
```
  
```リストの要素を参照
リスト[添え字]
※割り振られていない添え字を指定するとエラーになる
```
  
```sum関数
sum(リスト)
※リストのすべての要素を合計した値に置き換わる
※文字列を格納しているリストには使えない
※後述するタプルやセットに対しても使用できる
```
  
```len関数
len(リスト)
※リストの要素数に置き換わる
※後述するディクショナリ、タプル、セットに対しても使用できる
```
  
```リストの末尾に値を追加
リスト.append(リストに追加したい値)
※指定した値が、リストの末尾に新たな要素として追加される
```
  
```リストから指定した値を削除
リスト.remove(リストから削除したい値)
※削除した要素の後ろの要素は前に詰められる
```
  
```リストの要素を変更
リスト[変更要素の添え字]=変更後の値
```

  

変数名で用意しても大丈夫だけど関数であるからsumを使うのは少し気持ち悪い
  
```members.append('菅原')```  
```members.append('湊')```  
```members.append('朝香')```  
```print(members)```  
appendで足すか、  
  
```members=members+['菅原','湊','朝香']```  
配列を足し算でも足せる  
  
クリアオールアウトプッツみたいなので実行結果を消せる  
  
インデックスで消すなら  
```del members[0]```  
  
最後の要素なら
```del members[-1]```  
  
**①スライスによる範囲指定**  
リストで要素を指定する際、**スライス(slice)**という構文を用いることで、連続した範囲にある要素を参照することができます  
  
```スライスによる範囲指定
リスト変数[A:B]
※添え字がA以上B未満の要素を参照する部分リストに評価される
※「A:」と指定すると、添え字がA以上のすべての要素を参照する
※「:B」と指定すると、添え字がB未満のすべての要素を参照する
※「:」だけを指定すると、すべての要素を参照する
```
  
```a=[10,20,30,40,50]```  
```print(a[1:3]) # 添え字が1以上3未満の要素```  
```print(a[2:]) # 添え字が2以上のすべての要素```  
```print(a[:3]) # 添え字が3未満のすべての要素```  
```実行結果```  
```[20,30]```  
```[30,40,50]```  
```[10,20,30]```  

# ディクショナリ

JSのオブジェクトと作り方同じ  
  
**ディクショナリは波かっこ**  
  
```ディクショナリの定義
変数={キー1:値1,キー2:値2,…}
※キーと値の対応を、：(コロン)を使って指定する
```
  
・キーには、文字列のほか数値型など、様々な型のデータを指定できる  
・キーのデータ型は要素ごとに異なってもよい  
・キーの重複も許される(ただし、最後に指定したもの以外は無視される)  
  
```ディクショナリの要素を指定
ディクショナリ[キー]
※キーは大文字/小文字を区別する
```
  
```ディクショナリの要素を追加
ディクショナリ[新しいキー]=新しい値
```
  
```ディクショナリの既存の要素を変更
ディクショナリ[変更したい要素のキー]=変更後の値
```
  
```ディクショナリの要素を削除
delディクショナリ[削除したい要素のキー]
```
  
```リストとディクショナリの使いどころ
・複数のデータを単にまとめて管理したい場合や、順序を持つ複数のデータを管理したい場合にはリストを使う
・順序を持たない複数のデータに見出しをつけて管理したい場合には、ディクショナリを使う
```
  
## ディクショナリの合計
リストと違い、ディクショナリの場合はsum関数を使用して格納している値の合計を求めることができません。ディクショナリで合計を求めるには、次のように記述します  
```scores={'network':60,'database':80,'security':50}```  
```total=sum(scores.values())```  
```print(total)```  
「**ディクショナリ.values() **」と記述することで、ディクショナリのキーを除いた、値だけからなる集まり(60、80、50)を取得することができます。この集まりは、リスト、セット、タプルとも違う、また別の種類のコレクションですが、sum関数を使用することができます  
  
辞書は～が～って教えてくれるのと同じ感じ  
Pythonでは辞書作ってる  
JSではオブジェクト作ってる  
  
配列をリストという  
  
ディクショナリはJavaでいえばハッシュマップ  
マップの概念は言語を超えてる  
マップっていうのは～と～を繋げる  
  
## タプルとセット

**タプル**  
**タプル(tuple)**とはリストとほぼ同じ特徴を持つコレクションです。唯一、「**要素の追加、変更、削除ができない**」という点だけが異なります。概ね「中身が変更できないリスト」と考えて差し支えありません  
  
```タプルの定義
変数={値1,値2,値3,…}
※要素を追加、変更、削除することはできない
```
  
「データを変更できない」という不便さは**「データが書き換えられていないことを保証できる」**というメリットと表裏一体です  
  
```リストとタプルの使いどころ
・書き換える可能性のある複数のデータを単にまとめて管理したい場合は、リストを使う
・書き換える可能性のない複数のデータを単にまとめて管理したい場合は、タプルを使う
```
  
タプルは書き換えのできないリスト(配列)  
配列の定数みたいな  
  
**タプルは丸括弧で書く**  
丸括弧なしでもできるけど、わかりにくいから丸括弧付けとくほうがいい  
  
タプルはイミュータブル(不変)だから書き換えができない  
  
リストとタプルはシーケンスと総称されることもあります  
  
**タプルの注意点**  
要素数１つだとタプルだと解釈されないから、要素数１つで作りたかったらカンマをつける  
  
## セット

**セット**  
①重複した値を格納することができない  
②添え字やキーという概念がなく、特定の要素に対して代入・参照する方法が存在しない  
③添え字がないため、要素は順序を持たない  
④append関数の代わりにadd関数で要素を追加する  
  
```セットは種類を管理する
セットは順序を持たず、その要素は重複しないため、「種類」の管理に向いている
```
  
```セットの定義
変数={値1,値2,…}
```
  
  
```コレクションたちの別名```  
  
| 本書で紹介したコレクション  | 別名  | 説明  |
|---|---|---|
| リスト  | 配列(array)  |  ほかのプログラミング言語では「配列」が多い |
| ディクショナリ  | 辞書、マップ(map)  | マップは対応表という意味  |
| セット  | 集合  | 集合も順序がないことを示す  |
| タプル  | ー  | 別名は特になし  |
 
   

**リストには順番の概念があるので末尾に加えるという意味のappend  
セットには順番の概念がないので加えるという意味のadd**  
で値の追加を行う  

---


## コレクションの応用

**コレクションの相互変換**  
  
```リスト・タプル・セットへの変換```  
  
| 関数  | 説明  |
|---|---|
| list関数  |  渡されたものをリストに変換する※1 |
| tuple関数  | 渡されたものをタプルに変換する※1  |
|  set関数 | 渡されたものをセットに変換する※2  |
```※1　もともと順序関係がないディクショナリやセットからは、変換の際にどのような順序で要素が並べられるかは保証されない```  
```※2　もともと重複が許されるリストやタプルからは、変換の際に重複が排除される```  
```※3　「list()」のように、何も指定せずにこれらの関数を呼び出すと、空のコレクションを作成することができる```  
  
**ディクショナリへの変換**  
ディクショナリへのはキーと値の2種類の情報をペアで管理するコレクションであるため、単一のリストやセットからは変換できません。「キーを格納したリスト」と「値を格納したリスト」の2つが存在する場合、「**dict(zip(キーのリスト、値のリスト))**」という構文で1つのディクショナリに変換できます  
  
---
  
# 集合演算
  
```セットの＆演算
セット1&セット2
※セット１とセット２の両方に含まれる要素からなるセットに評価される
```
  
| 集合演算  | 使う演算子  |
|---|---|
| 和集合  | ```|```演算子  |
|  差集合  | ```-```演算子  |
| 積集合  |  ```&```演算子 |
| 対称差  |  ```^```演算子 |
  
   
# 条件分岐

## if文
Javaのif文の丸括弧と波カッコがなくなったような感じ  
コロンが増えて、インデントがブロックを意味してる  
インデントに意味があるから揃えないでずらしてしまうとエラー  
  
```インデントでブロックを指定する
ブロックの範囲はインデントによって指定する
```
  
```if文の基本構文
if条件式:
    条件が成立したときの処理(ifブロック)
else:
    条件が成立しなかったときの処理(elseブロック)
※ブロックはインデント(字下げ)によって指定する
```
  
# 条件式
  
Javaと同じ  
  
## in演算子
**in演算子**は、右辺に左辺の値が含まれているかを判定することができる比較演算子です  
  
**ディクショナリのキーをチェックする**  
  
```ディクショナリのキーの存在を調べる
キー in ディクショナリ
※キーがディクショナリに存在する場合は条件成立、存在しない場合は条件不成立となる
```
  
## 真偽値
  
Javaと同じだけどTとFが大文字  
True、False  
  
**条件式の評価結果を確認する**
  
## 論理演算子
  
```論理演算子とその意味```  
  
|  演算子  |  意味 |
|---|---|
| and  | かつ  |
| or  |  または |
| not  | でなければ(否定)  |
  
# 分岐構文のバリエーション
  
```if-else構文
if条件式:
    条件式が成立したときの処理
else:
    条件式が成立しなかったときの処理
```
  
```if文のみの構文
if条件式:
    条件式が成立したときの処理
```
  
## 空ブロックの作り方
Pythonでは空のブロックを禁じているため、ifのみの構文を使用せずに、何も処理をしない空のelseブロックを書くとエラーになります。ブロックの中を空にしたい場合は、**pass**とだけ書いて、何もしないことを表明する必要があります  
  
## 多分岐するif文
```if-elif構文
if 条件式1:
    条件式1が成立したときの処理
elif 条件式2:
    条件式1が成立せず、条件式2が成立したときの処理
```
  
```
elif 条件式 n:
    上記の条件がすべて成立せず、条件式nが成立したときの処理
else:
    すべての条件式が成立しなかったときの処理
※elseブロックは省略可能(「else:」事態の記述が不要)
```
  

## 三項条件演算子
```
値1 if 条件式 else 値 2
※条件式が成立すれば値１に、そうでなければ値２に全体が「化ける」
```
  
divに偶数が入るかどうか  
divのイコールの右をひとまとめで評価する  
```div='偶数' if number % 2==0 else '奇数'```  
```print('{}'です'.format(div))```  
  
Javaなら  
```int number=4```  
```String div=number%2==0 ? "偶数":"奇数";```  
```System.out.printf("%s"です%n",div);```  

# 繰り返し
  
```while文
while条件式:
条件が成立したときの処理(whileブロック)
※ブロックはインデント(字下げ)によって指定する
```
  
**繰り返しを使って得点リストを作成する**  
  
```score_list=list() ```  
と  
```score_list=[]```  
は同じ  
  
```score_list=list() ```  
```list()```は、リストに変換するとかそういうの  
それを引数いれずに何も指定せずに作ると空のリストを作ってくれる  
  
**リストの全要素を繰り返し参照する**  
  
```繰り返しを利用してリストの要素を参照する
カウンタ変数=0
whileカウンタ変数<len(リスト):
    リスト[カウンタ変数]を使った処理
    カウンタ変数+=1
```
  
## for文

**for文でリストの全要素を参照する**  
  
拡張for文のイメージ  
  
```for文でリストの全要素を参照する
for 変数 in リスト:
    繰り返し処理
```
  
for elseもある  
まわり終わったらelseを通る  
全部まわり切ったかどうか  
  
**for文で決まった回数を繰り返す**  
  
```range関数
range(n)
※0以上ｎ未満までの範囲の整数列に評価される
```
  
```for文で決まった回数を繰り返す
for 変数 in range(n):
        繰り返し処理
※繰り返しはｎ回実行される
```
  
**整数列はリストのようなものと考えておけばOK**  
  
rangeを使うと並び式を作ってくれる  

## while文とfor文の使い分け
  
```while文とfor文の使い分け
・while文:繰り返す回数の目処が立たないときに使う
・for文:繰り返す回数の目処が立つときに使う
```
  
# 繰り返しの制御

データのまとまりからサンプルを抽出する  
目標数に達したら繰り返しを終了する  
  
**break文**  
  
繰り返しのスキップ  
  
不要な回のループをスキップする  
  
```instance関数
instance(データ型,データ型)
※データがデータ型と一致したらTrueに置き換わる
※データ型にはint、str、boolなどが使用できる
```
  
JavaでinstanceOfがあった  
本当のオブジェクト型を確認してダウンキャストできるかどうかを判断したりした  
多分アニマルアプリとかで  
  
intクラスのインスタンスじゃないからスキップ  
  
**break文とcontinue文**  
  
---
  
# 関数

関数は使うだけでなく、作れる  
  
プログラムを複数の部品に分けることを**部品化**といいます  
メソッド分割  
  
### 部品化のメリット
* プログラム全体の見通しが良くなり、処理を把握しやすくなる(プログラムの可読性が向上する)
* 機能ごとに関数を記述する為、修正範囲を限定できる(プログラムの保守性が向上する)
* 何度も使う機能を関数にまとめることで、プログラミングの作業効率が上がる

  

**定義**(defnition)  
**呼び出し**(call)  

### 関数の定義と呼び出し
* ステップ1:関数の定義
 呼び出されたらどのような動作を行うかを記述し、名前を付ける
* ステップ2:関数の呼び出し
関数の名前を記述して関数を呼び出す。定義された動作が実行される 

  
```シンプルな関数の定義
def 関数名 ():
    処理
※処理はインデントとして記述する。
```
  
```シンプルな関数の呼び出し
関数名()
```
  
### 関数名の衝突による上書き
すでに定義されている関数と同じ名前を付けると、以前の関数は呼び出せなくなる  

### ローカル変数の独立性
* 関数の中で定義された変数は、その関数の中でしか使えない
* その関数の外やほかの関数の中に偶然同じ名前の変数があったとしても、まったく無関係な存在として扱われる

  
引数を厳密に区別したい場合は、  
渡すデータを**実引数**、そのデータを受け取る変数を**仮引数**と呼び分けます  
  

```引数を利用する関数の定義
def 関数名(引数1,引数2,…):
        処理
```
  
```引数を利用する関数の呼び出し
関数名(引数1,引数2,…)
```
  
### 引数として渡せるデータ
引数には、数値や文字列はもちろん、コレクションも引き渡すことができる  
  
```def calc_average(scores:list):```  
```def calc_average(scores:'リストみたいなもの')```  
仮引数にコロンと型を書いて、ヒントを付けられる  
コメントも書ける  
  

```引数と戻り値を利用する関数の定義
def 関数名(引数1,)引数2,…):
    処理
    return 戻り値
※引数は複数の指定が可能だが、戻り値は1つのみ
```
  

### 関数呼び出し演算子の働き
* 評価されると、左カッコの直前に記述された関数を呼び出す。その際、左カッコと右カッコの間に記述された引数を呼び出し先に引き渡し、実行完了を待つ
* 呼び出した関数の実行が完了すると、返ってきた戻り値に「化ける」
  
```def plus(x:int,y:int):```  
ってヒントを付けとくと実行環境によったら教えてくれるらしい  
エラーではないからエラーは出ない  
strとstrで文字連結みたいなのはできちゃう  
  

```引数と戻り値を利用する関数の呼び出し
戻り値を受け取る変数名=関数名(引数1,引数2,…)
```
  

### 空っぽを意味するNone
関数定義の末尾に明示的なreturn文が登場しない場合は、「**return None**」という記述をしたものとみなされます。**None**は、Pythonの世界では「**何もない状態**」「**空っぽ**」を意味するために準備された特殊な値です。print関数など、返すべき戻り値が特にない関数はNoneを返しています。  

# 関数の応用テクニック

**暗黙のタプルによる複数の戻り値**  
カンマ区切りがタプル  
```a,b=3,5``` もタプル  
  
タプルが戻り値  
タプルに対してアンパック代入してあげるとnextとprevにそれぞれ値が返って入る  
  

**デフォルト引数**  
  
```引数にデフォルト値を指定する関数の定義
def 関数名()仮引数名=デフォルト値,…)
処理
return 戻り値
※関数呼び出しで実引数が指定されない場合は、デフォルト値が指定されたものとみなされる
※デフォルト値を指定した以降の仮引数もデフォルト値の指定が必須となる
```
  

### デフォルト引数の制約
デフォルト引数が指定された仮引数より後ろに、デフォルト引数がない仮引数を定義してはならない  
  
デフォルト引数を利用する場合は、必ず一番後ろの引数から順にデフォルト値を指定するようにしましょう  
  

```引数にキーワードを指定した関数呼び出し
関数名(仮引数名 1=実引数 1,仮引数名 2=実引数 2,…)
※実引数として列挙された順番にかかわらず、値は指定された仮引数に引き渡される
```
  
```可変長引数を利用した関数定義
def 関数名(仮引数名 1,仮引数名 2,…,*仮引数名 n):
```
```※呼び出し時にn個以上の実引数を指定することができる```
```※第n引数以降に指定した実引数は、1つのタプルとして受け取る```
```※第n実引数の指定が省略された場合、関数は空のタプルを受け取る```
```※可変長引数は、末尾の仮引数にしか指定することができない```

### ディクショナリを用いた可変長引数
可変長引数にタプルではなくディクショナリを用いることもできます。仮引数の前につける「```*```」を2つにすると、実引数をディクショナリとして受け取ることができます  
  
可変長引数がタプルの場合は仮引数名を「```*args```」、ディクショナリの場合は「```**kwargs```」とする慣習があります  

kwargs キーワードアーグス  

# グローバル変数

```global文
global 変数名
```
  
グローバル空間(みんなが使える)に変数nameがある  
  
グローバル変数は便利  
関数は副作用がないほうが本当は良い  
  
グローバルの話もPythonだけの話じゃない  

  
```グローバル変数を濫用するリスク
　グローバル変数は便利だが、開発者の混乱やミスを招きやすいという副作用がある。自分一人だけの開発では問題になりにくいが、チームでの開発や中規模以上の開発には向かない。
```
  
---
  
