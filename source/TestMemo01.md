# テスト前に確認しておきたいメモ①

メモでテストで検索してひっかかったやつ

## オーバーロード

オーバーロードは同じ名前のメソッドを複数定義できる  
<span style="color: red; ">テストに出やすい</span>  
これはオーバーロードできるかとか  

## コンストラクタ

コンストラクタは直接呼び出せない  
  
**コンストラクタと見なされる条件**  
<span style="color: red; ">①メソッド名がクラス名と完全に等しい  
②メソッド宣言に戻り値が記述されていない(voidもダメ)</span>  
  
Javaはコンストラクタがひとつも定義されてないクラスは許されない  
  
**コンストラクタの特例**  
クラスに一つもコンストラクタが定義されていない場合に限って、  
引数なし、処理内容なしのコンストラクタ(デフォルトコンストラクタ)がコンパイル時に自動的に追加される  
  
```this(引数);```  
  
コンストラクタの呼び出しは必ず1行目に。  
1個しか呼び出せない  
  
```this();```  
自分のクラスのコンストラクタの呼び出し  
引数がない  
  
コンストラクタはnewしたときしか取らない  
  
コンストラクタを増やしたら  
デフォルトコンストラクタがなくなるので引数がないとコンパイルエラーになるが、  
```Slime(){};```  
と一文足すとコンパイルエラーにならない。**  
<span style="color: red; ">こういうのはテストによく出る</span>  
暗黙のルール  

---

## Java時間計測
Javaで時間を計測するには以下の方法を用いればよい  
開始のタイミング  
```long start=System.currentTimeMillis();```  
//何かしらの処理  
  
終了のタイミング  
```long end=System.currentTimeMillis();```  
  
```long diff=end-start;//かかった時間(ms)```  

---

# 継承
```public class SuperHero <span style="color: red; ">extends</span> Hero```  
  
<span style="color: red; ">とても大事</span>  
  
Javaは一度しか継承できない  
  
親クラスは常にひとつ  
  
親を複数持てない  
  
  
```String```クラスは継承禁止  
```final```のついているクラスは継承できない  

クラス宣言に```final```をつけると継承禁止  
メソッド宣言に```final```をつけるとオーバーライド禁止  
フィールドのオーバーライド禁止

**メンバ＝フィールドとメソッドのこと**

```super.フィールド名```
```super.メソッド名(引数)```

すべてのコンストラクタは、
その先頭で必ず内部インスタンス部分(親クラス)のコンストラクタを呼び出さなければならない  
```super();```あってもなくても意味は同じ  
  
コンストラクタの1行目に```super();``` という行が自動的に挿入されます  

```public SuperHero(){```
```super();```
```}```

```super();```
書くと
```this();```
は書けない  

内側のインスタンス部分から動いていく

---

### 継承するときはis-aの関係を確認
### is-aの原則
子クラスis-a親クラス(子クラスは、親クラスの一種である)  
もし、「(子クラス)is-a(親クラス)」「(子クラス)は(親クラス)の一種である」  
という文章を作って不自然さを感じたら継承の誤りを疑いましょう  

is-aの原則が成立しないならば、ラクができるとしても継承を使ってはならない  

### 汎化・特化の関係
継承はある2つのクラスに汎化・特化の関係があることを示すための道具でもある

---

## スーパークラス
### スーパークラス(は、親クラス)
コンストラクタの中では一行目にスーパークラスのコンストラクタか自分自身のコンストラクタを呼び出さなければならない  
```super()```
```this()```
書いてないと暗黙で```super()```が呼び出される  
何も継承してないクラスの場合は暗黙で<span style="color: red; ">Object</span>クラスが継承されている  

スーパークラス、サブクラス  
親クラス、子クラス  

```super. ```で呼び出せるのは一個上だけだけど継承はいくつもできる

---

### 詳細未定のメソッド(抽象メソッド)を宣言
```public abstract 戻り値 メソッド名(引数リスト);```

```abstract(アブストラクト)は抽象的、あいまいという意味```  
```abstract```キーワードがつけられたメソッドは、抽象メソッド(abstract method)と呼ばれる  

未完成部分を含む継承専用のクラスを誤ってnewされる可能性がある  
### 抽象メソッドを含むクラスの宣言
```public abstract class クラス名{```
```}```

Javaのルールで、抽象メソッドを含むクラスは必ず```abstract```付きのクラスにしなければならない。  
もし1行目の```abstract```を忘れたらコンパイルエラーになる  
抽象クラスは、```new```によるインスタンス化が禁止される  
  
未来の開発者が、詳細未定のメソッドをオーバーライドし忘れる可能性がある  
〇〇クラスを継承して▲▲クラスを作ったとして、  
〇〇クラスに抽象メソッドがあると  
▲▲クラスには抽象メソッドがなくても  
〇〇クラスを継承しているから抽象クラスにしないとコンパイルエラー。  
  
このエラーに対処する方法には次の2つある  
<span style="color: red; ">①▲▲クラスの宣言にabstractを付けて抽象クラスにする。  
②▲▲クラス内部の「未完成部分」をすべてなくす</span>  

②をしてすべてのメソッドの動作が実装されて詳細未定な部分が残っていない場合、newして使える通常のクラスになった  
「抽象クラスはnewできない」というルールがJavaにある以上、  
「あるメソッドを抽象メソッドとして宣言しておくことで、  
未来の開発者にオーバーライドを継承できる(オーバーライドしないとnewして使えない)」   
という効果があるとも言えます  
  
  
attackメソッドはみんなもってるけど、中身を決められないみたいな場合は抽象メソッドにする。  
ひとつでも抽象メソッドがあるならクラスも抽象クラスにしなければいけない  

抽象クラスの反対は具象クラス  

---

# インタフェース
### インターフェースとして特別扱いできる２つの条件
<span style="color: red; ">①すべてのメソッドは抽象メソッドである。　　
②基本的にフィールドを１つも持たない。</span>　　

### インタフェースの宣言
```public interface インタフェース名{  }```

### インタフェースの実装
```public class クラス名 implements インタフェース名{  }```

**implements インプリメンツ**　　
  
インタフェースを実装　　
継承という言い方ではない　　
  
実装する(```implements```)という用語が使われるのは、  
親インタフェースで未定だった各メソッドの内容を　　
オーバーライドして実装し確定させるから。  
  
### インタフェースの効果
<span style="color: red; ">①同じインタフェースをimplementsする複数の子クラスたちに、共通のメソッド群を実装するよう強制できる。　　
②あるクラスがインタフェースを実装していれば、少なくともそのインタフェースが定めたメソッドは持っていることが保証される。</span>　　
  
### クラスにはないインタフェースの特権
異なる実装が衝突する問題が発生しないため、複数の親インタフェースによる多重継承が認められている。  
  
### インタフェースによる多重継承
```public class  クラス名  implements 親インタフェース名1,親インタフェース名2,{```
```}```
  
多重継承が許されている　　
<span style="color: red; ">テスト穴埋めで</span>
<span style="color: red; ">interface</span> のフェースをsにするひとがいるけど気を付けて　　
  
### オラクルででるような試験問題
```public void sellTabacco``` の ```public```をなくすと  
オーバーライドのルールでアクセス修飾子は同じか弱める方法にしか変更しちゃいけない  
強める方向に変更するとコンパイルエラー  
**インタフェースは暗黙で```public```**  
```public```が一番弱い、誰からでもアクセスできるから　　
```protected```  
```無印```  
一番強いのは```private```  
  
インタフェースはpublic以外はだめ  
  
オーバーライドするときは絶対publicを書かないとだめ  
　　

|  制御のレベル | 名称  | 指定方法  |  アクセスを許可する範囲 |
|---|---|---|---|
| 制限が厳しい  | private  | praivate  | 自分自身のクラスのみ  |
|　  ↑  |  package private | (何も書かない)  |  自分と同じパッケージに属するクラス |
|　  ↓ | protected  |  protected |  自分と同じパッケージに属するか、自分を継承した子クラス |
|  制限が緩い | public  |  public |  すべてのクラス |
　　　
**メンバに関するアクセス修飾の定石**　　
・フィールドはすべて**<span style="color: blue; ">private</span>**　　
・メソッドはすべて**<span style="color: blue; ">public</span>**　　
  
基本的には全部privateで必要なものだけpublicがいいかも  


# キャスト

### 「箱の型」と「中身の型」
<span style="color: red; ">**箱の型**　</span>　どのメソッドを「呼べるか」を決定する。  
<span style="color: red; ">**中身の型**</span>　メソッドが呼ばれたら、「どう動くか」を決定する。  
  
キャスト演算子は強制的な型変換をコンパイラに対して明示的に指示する、とても強力な演算子です。  
  
親クラスから子クラスにキャストすることを<span style="color: red; ">ダウンキャスト</span>という  

3段階で考えればいい  
まずその変数に代入可能か  
その型の変数に入れた場合どのメソッドが呼び出せるか  
実際にどれが動くか  
<span style="color: red; ">
テスト範囲に入る</span>
テストに出たら図を書いたらいい  

# getter  setter

値を取得する為だけのメソッド**getter**  
値を代入する為だけのメソッド**setter**  
  
この二つは書き方のルールが決まってるから、特に考えることはない  
setterは値をセットするのが目的だから引数ありの戻り値なし(戻り値は関係ない)  
引数に入ってきた情報を自分のフィールドにセットする  
getterは値を取得するのが目的だから戻り値はいるけど引数はいらない  
自分のフィールドを返す  
  
private修飾された nameフィールドに対して  
getterとsetterを記述せよ、<span style="color: red; ">っていうテストが出てもおかしくない</span>  
  
setterは検査を徹底する  

---


### getterメソッドの定石
**public フィールドの型 getフィールド名(){
　　return this.フィールド名;
}
**
### setterメソッドの定石
**public void setフィールド名(フィールドの型 任意の変数名){
　　this.フィールド名=任意の変数名;
}
**

---

**getter と setterはアクセサ(accessor)と総称されることもあるんだが、アクセサには重要な存在価値がある**

---

# ArrayList
**1.import文を記述する**  
ArrayListクラスをはじめとするコレクションクラスはjava.utilパッケージに属していますので、  
通常  
  
**<>ダイヤモンド演算子**  
**ジェネリクス**  
**<span style="color: red; ">この中は参照型しか書けない</span>**  
  
**ArrayList<型> 変数名 = new ArrayList<型>();**  
  
```ArrayList<String> names=new ArrayList<>();```  
  
**Java7か8から後ろは型を書かなくてもよくなった**  
  
**ArrayList**は**<span style="color: blue; ">get</span>**メソッドを使って値を取得する  
  
オートボクシング  

```ArrayList```というのは  
リストインタフェースを実装している  
この中に```get```とか```size```という抽象メソッドがある。  
```ArrayList```はそれを継承している  
  
現場では```ArrayList```じゃなく```List```って書く  
```List points=new ArrayList();```  
```Listインタフェース型```  
ここだけ書き換えて```LinkedList```とかに出来る  
処理速度が違ったりして変えたりする
